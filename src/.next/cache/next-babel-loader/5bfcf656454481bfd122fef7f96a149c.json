{"ast":null,"code":"import _slicedToArray from \"/Users/pulkitshah/Desktop/truckarv2/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/* eslint-disable no-bitwise */\nexport var JWT_SECRET = 'devias-top-secret-key';\nexport var JWT_EXPIRES_IN = 3600 * 24 * 2; // 2 days\n// Since we are unable to sign a JWT in a browser\n// because \"jsonwebtoken\" library is available on server side only, NodeJS environment\n// we simply simulate a signed token, no complex checks because on server side\n// you're using the library\n\nexport var sign = function sign(payload, privateKey, header) {\n  var now = new Date();\n  header.expiresIn = new Date(now.getTime() + header.expiresIn);\n  var encodedHeader = btoa(JSON.stringify(header));\n  var encodedPayload = btoa(JSON.stringify(payload));\n  var signature = btoa(Array.from(encodedPayload).map(function (item, key) {\n    return String.fromCharCode(item.charCodeAt(0) ^ privateKey[key % privateKey.length].charCodeAt(0));\n  }).join(''));\n  return \"\".concat(encodedHeader, \".\").concat(encodedPayload, \".\").concat(signature);\n}; // Since we create a fake signed token, we have to implement a fake jwt decode\n// platform to simulate \"jwt-decode\" library.\n\nexport var decode = function decode(token) {\n  var _token$split = token.split('.'),\n      _token$split2 = _slicedToArray(_token$split, 3),\n      encodedHeader = _token$split2[0],\n      encodedPayload = _token$split2[1],\n      signature = _token$split2[2];\n\n  var header = JSON.parse(atob(encodedHeader));\n  var payload = JSON.parse(atob(encodedPayload));\n  var now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  var verifiedSignature = btoa(Array.from(encodedPayload).map(function (item, key) {\n    return String.fromCharCode(item.charCodeAt(0) ^ JWT_SECRET[key % JWT_SECRET.length].charCodeAt(0));\n  }).join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};\nexport var verify = function verify(token, privateKey) {\n  var _token$split3 = token.split('.'),\n      _token$split4 = _slicedToArray(_token$split3, 3),\n      encodedHeader = _token$split4[0],\n      encodedPayload = _token$split4[1],\n      signature = _token$split4[2];\n\n  var header = JSON.parse(atob(encodedHeader));\n  var payload = JSON.parse(atob(encodedPayload));\n  var now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  var verifiedSignature = btoa(Array.from(encodedPayload).map(function (item, key) {\n    return String.fromCharCode(item.charCodeAt(0) ^ privateKey[key % privateKey.length].charCodeAt(0));\n  }).join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};","map":{"version":3,"sources":["/Users/pulkitshah/Desktop/truckarv2/renderer/utils/jwt.js"],"names":["JWT_SECRET","JWT_EXPIRES_IN","sign","payload","privateKey","header","now","Date","expiresIn","getTime","encodedHeader","btoa","JSON","stringify","encodedPayload","signature","Array","from","map","item","key","String","fromCharCode","charCodeAt","length","join","decode","token","split","parse","atob","Error","verifiedSignature","verify"],"mappings":"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","sourcesContent":["/* eslint-disable no-bitwise */\nexport const JWT_SECRET = 'devias-top-secret-key';\nexport const JWT_EXPIRES_IN = 3600 * 24 * 2; // 2 days\n\n// Since we are unable to sign a JWT in a browser\n// because \"jsonwebtoken\" library is available on server side only, NodeJS environment\n// we simply simulate a signed token, no complex checks because on server side\n// you're using the library\nexport const sign = (payload, privateKey, header) => {\n  const now = new Date();\n  header.expiresIn = new Date(now.getTime() + header.expiresIn);\n  const encodedHeader = btoa(JSON.stringify(header));\n  const encodedPayload = btoa(JSON.stringify(payload));\n  const signature = btoa(Array\n    .from(encodedPayload)\n    .map((item, key) => (String.fromCharCode(item.charCodeAt(0) ^ privateKey[key\n    % privateKey.length].charCodeAt(0))))\n    .join(''));\n\n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n};\n\n// Since we create a fake signed token, we have to implement a fake jwt decode\n// platform to simulate \"jwt-decode\" library.\nexport const decode = (token) => {\n  const [encodedHeader, encodedPayload, signature] = token.split('.');\n  const header = JSON.parse(atob(encodedHeader));\n  const payload = JSON.parse(atob(encodedPayload));\n  const now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  const verifiedSignature = btoa(Array\n    .from(encodedPayload)\n    .map((item, key) => (String.fromCharCode(item.charCodeAt(0) ^ JWT_SECRET[key\n    % JWT_SECRET.length].charCodeAt(0))))\n    .join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};\n\nexport const verify = (token, privateKey) => {\n  const [encodedHeader, encodedPayload, signature] = token.split('.');\n  const header = JSON.parse(atob(encodedHeader));\n  const payload = JSON.parse(atob(encodedPayload));\n  const now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  const verifiedSignature = btoa(Array\n    .from(encodedPayload)\n    .map((item, key) => (String.fromCharCode(item.charCodeAt(0) ^ privateKey[key\n    % privateKey.length].charCodeAt(0))))\n    .join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};\n"]},"metadata":{},"sourceType":"module"}